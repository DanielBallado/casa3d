<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>AR Hand Controller 3D</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background: #1e1e1e;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
            touch-action: none;
        }
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
        }
        #input_video { display: none; }
        #webgl_canvas, #hand_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }
        #webgl_canvas { z-index: 2; }
        #hand_canvas { z-index: 3; }
        .ui {
            position: absolute;
            padding: 8px;
            background: rgba(0,0,0,0.8);
            border-radius: 6px;
            z-index: 10;
            font-size: 11px;
        }
        #info { top: 10px; left: 10px; }
        #status { top: 10px; right: 10px; }
        #instructions { bottom: 10px; left: 50%; transform: translateX(-50%); text-align: center; }
        #loadingMsg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            background: rgba(0,0,0,0.95);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        #startBtn {
            padding: 15px 30px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
        }
        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #555;
            display: inline-block;
            margin-right: 5px;
        }
        .dot.active { background: #4CAF50; box-shadow: 0 0 8px #4CAF50; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="container">
        <div id="loadingMsg">
            <div>Cargando Casa 3D...</div>
            <button id="startBtn">Iniciar C√°mara</button>
        </div>
        
        <div id="info" class="ui">
            <div><strong>üè† Controles Casa 3D</strong></div>
            <div>ü§è Der: Rotar</div>
            <div>ü§è Izq: Mover</div>
            <div>ü§èü§è: Zoom</div>
            <div>‚úãü§è: Mover parte</div>
        </div>

        <div id="status" class="ui">
            <div><span class="dot" id="leftDot"></span><span id="leftText">Izq: --</span></div>
            <div><span class="dot" id="rightDot"></span><span id="rightText">Der: --</span></div>
        </div>

        <video id="input_video" playsinline></video>
        <canvas id="webgl_canvas"></canvas>
        <canvas id="hand_canvas"></canvas>
        
        <div id="instructions" class="ui">Esperando manos...</div>
    </div>

    <script>
        const vid = document.getElementById('input_video');
        const loading = document.getElementById('loadingMsg');
        const startBtn = document.getElementById('startBtn');
        const wgl = document.getElementById('webgl_canvas');
        const hnd = document.getElementById('hand_canvas');
        const ctx = hnd.getContext('2d');
        const inst = document.getElementById('instructions');
        const ldot = document.getElementById('leftDot');
        const rdot = document.getElementById('rightDot');
        const ltxt = document.getElementById('leftText');
        const rtxt = document.getElementById('rightText');

        let started = false;
        
        function resize() {
            const w = window.innerWidth, h = window.innerHeight;
            wgl.width = w; wgl.height = h;
            hnd.width = w; hnd.height = h;
            if (renderer) {
                renderer.setSize(w, h);
                cam.aspect = w / h;
                cam.updateProjectionMatrix();
            }
        }
        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => setTimeout(resize, 100));

        let obj = null;
        const scene = new THREE.Scene();
        const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: wgl, alpha: true, antialias: false });
        renderer.setClearColor(0x000000, 0);
        scene.add(new THREE.DirectionalLight(0xffffff, 2).add(new THREE.Object3D().translateOnAxis(new THREE.Vector3(5,5,5), 1)));
        scene.add(new THREE.AmbientLight(0x404040));
        cam.position.z = 5;
        resize();

        let ray = new THREE.Raycaster();
        let ms = new THREE.Vector2();
        let sel = null;
        let initPos = new THREE.Vector3();

        function buildHouse() {
            if (obj) scene.remove(obj);
            const grp = new THREE.Group();
            
            // Materiales
            const wm = new THREE.MeshPhongMaterial({ color: 0xE8D5B7, side: THREE.DoubleSide });
            const rm = new THREE.MeshPhongMaterial({ color: 0x8B4513, side: THREE.DoubleSide });
            const dm = new THREE.MeshPhongMaterial({ color: 0x654321, side: THREE.DoubleSide });
            const wim = new THREE.MeshPhongMaterial({ color: 0x87CEEB, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
            const cm = new THREE.MeshPhongMaterial({ color: 0xA52A2A, side: THREE.DoubleSide });
            const fm = new THREE.MeshPhongMaterial({ color: 0x8B7355, side: THREE.DoubleSide });
            const tbm = new THREE.MeshPhongMaterial({ color: 0xD2691E, side: THREE.DoubleSide });
            const chm = new THREE.MeshPhongMaterial({ color: 0xA0522D, side: THREE.DoubleSide });
            const bedm = new THREE.MeshPhongMaterial({ color: 0xFF6B6B, side: THREE.DoubleSide });
            
            const s = 3, h = 2, rh = 1.2;
            
            // PISO
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(s, s), fm.clone());
            floor.rotation.x = -Math.PI/2;
            floor.position.y = -h/2;
            floor.userData.f = true;
            floor.add(new THREE.LineSegments(new THREE.EdgesGeometry(floor.geometry), new THREE.LineBasicMaterial({color:0x555555})));
            grp.add(floor);
            
            // PAREDES (con apertura para puerta frontal)
            const wg = new THREE.PlaneGeometry(s, h);
            
            // Pared frontal (dividida por puerta)
            const fw1 = new THREE.Mesh(new THREE.PlaneGeometry(1, h), wm.clone());
            fw1.position.set(-s/2+0.5, 0, s/2);
            fw1.userData.f = true;
            fw1.add(new THREE.LineSegments(new THREE.EdgesGeometry(fw1.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(fw1);
            
            const fw2 = new THREE.Mesh(new THREE.PlaneGeometry(1, h), wm.clone());
            fw2.position.set(s/2-0.5, 0, s/2);
            fw2.userData.f = true;
            fw2.add(new THREE.LineSegments(new THREE.EdgesGeometry(fw2.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(fw2);
            
            const fw3 = new THREE.Mesh(new THREE.PlaneGeometry(1, 0.4), wm.clone());
            fw3.position.set(0, h/2-0.2, s/2);
            fw3.userData.f = true;
            fw3.add(new THREE.LineSegments(new THREE.EdgesGeometry(fw3.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(fw3);
            
            // Otras paredes
            const bw = new THREE.Mesh(wg, wm.clone());
            bw.position.set(0, 0, -s/2);
            bw.rotation.y = Math.PI;
            bw.userData.f = true;
            bw.add(new THREE.LineSegments(new THREE.EdgesGeometry(bw.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(bw);
            
            const lw = new THREE.Mesh(wg, wm.clone());
            lw.position.set(-s/2, 0, 0);
            lw.rotation.y = -Math.PI/2;
            lw.userData.f = true;
            lw.add(new THREE.LineSegments(new THREE.EdgesGeometry(lw.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(lw);
            
            const rw = new THREE.Mesh(wg, wm.clone());
            rw.position.set(s/2, 0, 0);
            rw.rotation.y = Math.PI/2;
            rw.userData.f = true;
            rw.add(new THREE.LineSegments(new THREE.EdgesGeometry(rw.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(rw);
            
            // TECHO A DOS AGUAS (forma triangular realista)
            const roofW = s * 1.1;
            const roofD = s * 0.6;
            
            const rl = new THREE.Mesh(new THREE.PlaneGeometry(roofW, roofD), rm.clone());
            rl.position.set(0, h/2 + rh/2, -roofD/4);
            rl.rotation.x = -Math.PI/6;
            rl.userData.f = true;
            rl.add(new THREE.LineSegments(new THREE.EdgesGeometry(rl.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(rl);
            
            const rr = new THREE.Mesh(new THREE.PlaneGeometry(roofW, roofD), rm.clone());
            rr.position.set(0, h/2 + rh/2, roofD/4);
            rr.rotation.x = Math.PI/6;
            rr.userData.f = true;
            rr.add(new THREE.LineSegments(new THREE.EdgesGeometry(rr.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(rr);
            
            // Tri√°ngulos laterales del techo
            const tShape = new THREE.Shape();
            tShape.moveTo(0, 0);
            tShape.lineTo(s/2, 0);
            tShape.lineTo(s/4, rh);
            tShape.lineTo(-s/4, rh);
            tShape.lineTo(-s/2, 0);
            
            const tl = new THREE.Mesh(new THREE.ShapeGeometry(tShape), wm.clone());
            tl.position.set(0, h/2, s/2);
            tl.userData.f = true;
            tl.add(new THREE.LineSegments(new THREE.EdgesGeometry(tl.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(tl);
            
            const tr = new THREE.Mesh(new THREE.ShapeGeometry(tShape), wm.clone());
            tr.position.set(0, h/2, -s/2);
            tr.rotation.y = Math.PI;
            tr.userData.f = true;
            tr.add(new THREE.LineSegments(new THREE.EdgesGeometry(tr.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(tr);
            
            // PUERTA
            const door = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 1.2), dm.clone());
            door.position.set(0, -h/2+0.6, s/2+0.01);
            door.userData.f = true;
            door.add(new THREE.LineSegments(new THREE.EdgesGeometry(door.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(door);
            
            // VENTANAS
            const wig = new THREE.PlaneGeometry(0.5, 0.5);
            [[-0.7, 0.3, s/2+0.01, 0, 0, 0], [0.7, 0.3, s/2+0.01, 0, 0, 0],
             [-s/2-0.01, 0.2, -0.5, 0, -Math.PI/2, 0], [s/2+0.01, 0.2, 0.5, 0, Math.PI/2, 0]].forEach(w => {
                const wi = new THREE.Mesh(wig, wim.clone());
                wi.position.set(w[0], w[1], w[2]);
                wi.rotation.set(w[3], w[4], w[5]);
                wi.userData.f = true;
                wi.add(new THREE.LineSegments(new THREE.EdgesGeometry(wi.geometry), new THREE.LineBasicMaterial({color:0x000000})));
                grp.add(wi);
            });
            
            // CHIMENEA
            const chimney = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.8, 0.4), cm.clone());
            chimney.position.set(0.8, h/2 + rh/2 + 0.2, 0.4);
            chimney.userData.f = true;
            chimney.add(new THREE.LineSegments(new THREE.EdgesGeometry(chimney.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(chimney);
            
            // ===== MUEBLES INTERIORES =====
            
            // MESA (centro)
            const tableTop = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.05, 0.8), tbm.clone());
            tableTop.position.set(0, -h/2+0.4, 0);
            tableTop.userData.f = true;
            tableTop.add(new THREE.LineSegments(new THREE.EdgesGeometry(tableTop.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(tableTop);
            
            // Patas de mesa
            for(let x of [-0.3, 0.3]) {
                for(let z of [-0.3, 0.3]) {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.35, 0.05), tbm.clone());
                    leg.position.set(x, -h/2+0.2, z);
                    leg.userData.f = true;
                    leg.add(new THREE.LineSegments(new THREE.EdgesGeometry(leg.geometry), new THREE.LineBasicMaterial({color:0x000000})));
                    grp.add(leg);
                }
            }
            
            // SILLAS (4 alrededor de la mesa)
            const chairPos = [
                [0, -h/2+0.25, 0.6, 0],
                [0, -h/2+0.25, -0.6, Math.PI],
                [0.6, -h/2+0.25, 0, -Math.PI/2],
                [-0.6, -h/2+0.25, 0, Math.PI/2]
            ];
            chairPos.forEach(cp => {
                const seat = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.3), chm.clone());
                seat.position.set(cp[0], cp[1], cp[2]);
                seat.rotation.y = cp[3];
                seat.userData.f = true;
                seat.add(new THREE.LineSegments(new THREE.EdgesGeometry(seat.geometry), new THREE.LineBasicMaterial({color:0x000000})));
                grp.add(seat);
                
                const back = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.05), chm.clone());
                back.position.set(cp[0], cp[1]+0.25, cp[2]);
                back.rotation.y = cp[3];
                back.userData.f = true;
                back.add(new THREE.LineSegments(new THREE.EdgesGeometry(back.geometry), new THREE.LineBasicMaterial({color:0x000000})));
                grp.add(back);
            });
            
            // CAMA (esquina)
            const bed = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.2, 1.2), bedm.clone());
            bed.position.set(-s/2+0.5, -h/2+0.1, -s/2+0.7);
            bed.userData.f = true;
            bed.add(new THREE.LineSegments(new THREE.EdgesGeometry(bed.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(bed);
            
            const pillow = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 0.3), new THREE.MeshPhongMaterial({color:0xFFFFFF, side:THREE.DoubleSide}));
            pillow.position.set(-s/2+0.5, -h/2+0.25, -s/2+0.3);
            pillow.userData.f = true;
            pillow.add(new THREE.LineSegments(new THREE.EdgesGeometry(pillow.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(pillow);
            
            // ESTANTE (otra esquina)
            const shelf = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), new THREE.MeshPhongMaterial({color:0x8B4513, side:THREE.DoubleSide}));
            shelf.position.set(s/2-0.4, -h/2+0.4, -s/2+0.2);
            shelf.userData.f = true;
            shelf.add(new THREE.LineSegments(new THREE.EdgesGeometry(shelf.geometry), new THREE.LineBasicMaterial({color:0x000000})));
            grp.add(shelf);
            
            obj = grp;
            obj.scale.set(1.5, 1.5, 1.5);
            obj.position.set(0, -0.3, 0);
            obj.rotation.y = Math.PI/4;
            scene.add(obj);
        }
        buildHouse();

        const MP = 5;
        let rot=false, lrx=0, lry=0, lra=0, trx=0, try_=0, trz=0;
        let mv=false, sc=false, lsd=null, mvf=false, lfx=0, lfy=0;
        const RF=4.0, RZF=2.5, RS=0.25, PS=0.25, SS=20.0, FS=0.35;

        function dist(x1,y1,x2,y2) { return Math.sqrt((x2-x1)**2+(y2-y1)**2); }
        function ang(x1,y1,x2,y2) { return Math.atan2(y2-y1,x2-x1); }
        function n3d(x,y) { return {x:x*MP-MP/2, y:-(y*MP-MP/2)}; }
        function n2c(x,y) { return {x:(1-x)*wgl.width, y:y*wgl.height}; }
        function c2n(x,y) { return new THREE.Vector2(x/wgl.width*2-1, -(y/wgl.height*2-1)); }

        function rotR(it,tt) {
            if(!obj) return;
            const px=(it.x+tt.x)/2, py=(it.y+tt.y)/2;
            if(!rot) {
                rot=true;
                lrx=px; lry=py;
                lra=ang(it.x,it.y,tt.x,tt.y)*-1;
                trx=obj.rotation.x; try_=obj.rotation.y; trz=obj.rotation.z;
            } else {
                const dx=px-lrx, dy=py-lry;
                const ca=ang(it.x,it.y,tt.x,tt.y)*-1;
                try_+=dx*RF;
                trx+=dy*RF;
                let ad=ca-lra;
                if(ad>Math.PI) ad-=2*Math.PI;
                else if(ad<-Math.PI) ad+=2*Math.PI;
                trz+=ad*RZF*0.3;
                lrx=px; lry=py; lra=ca;
            }
            obj.rotation.x+=(trx-obj.rotation.x)*RS;
            obj.rotation.y+=(try_-obj.rotation.y)*RS;
            obj.rotation.z+=(trz-obj.rotation.z)*RS;
        }

        function movL(it,tt) {
            if(!obj) return;
            const p3=n3d((it.x+tt.x)/2,(it.y+tt.y)/2);
            obj.position.x+=(p3.x-obj.position.x)*PS;
            obj.position.y+=(p3.y-obj.position.y)*PS;
        }

        function zoom(lp,rp) {
            if(!obj) return;
            const d=dist(lp.x,lp.y,rp.x,rp.y);
            if(lsd!==null) {
                const dd=d-lsd;
                let ns=Math.max(0.5,Math.min(20,obj.scale.x+dd*SS));
                obj.scale.x+=(ns-obj.scale.x)*0.4;
                obj.scale.y+=(ns-obj.scale.y)*0.4;
                obj.scale.z+=(ns-obj.scale.z)*0.4;
            }
            lsd=d;
        }

        function movF(it,tt,ip) {
            if(!obj) return;
            const px=(it.x+tt.x)/2, py=(it.y+tt.y)/2;
            const p3=n3d(px,py);
            if(ip&&!sel&&!mvf) {
                const pc=n2c(px,py);
                ms=c2n(pc.x,pc.y);
                ray.setFromCamera(ms,cam);
                const its=ray.intersectObjects(obj.children.filter(o=>o.userData.f),false);
                if(its.length>0) {
                    sel=its[0].object;
                    sel.material.emissive.setHex(0x666666);
                    initPos.copy(sel.position);
                    lfx=p3.x; lfy=p3.y;
                    mvf=true;
                }
            } else if(ip&&sel&&mvf) {
                const dx=p3.x-lfx, dy=p3.y-lfy;
                const wm=new THREE.Vector3(dx,dy,0);
                const lm=wm.clone();
                lm.applyQuaternion(obj.quaternion.clone().invert());
                sel.position.x+=lm.x*FS;
                sel.position.y+=lm.y*FS;
                sel.position.z+=lm.z*FS;
                lfx=p3.x; lfy=p3.y;
            } else if(!ip&&sel) {
                sel.material.emissive.setHex(0x000000);
                sel=null; mvf=false;
            }
        }

        function onRes(res) {
            if(loading.style.display!=='none'&&obj) loading.style.display='none';
            ctx.save();
            ctx.clearRect(0,0,hnd.width,hnd.height);
            const hds=[];
            if(res.multiHandLandmarks&&res.multiHandedness) {
                for(let i=0;i<res.multiHandLandmarks.length;i++) {
                    const lm=res.multiHandLandmarks[i];
                    const h=res.multiHandedness[i].label;
                    const it=lm[8], tt=lm[4];
                    const ip=dist(it.x,it.y,tt.x,tt.y)<0.10;
                    const io=dist(lm[5].x,lm[5].y,it.x,it.y)>0.12&&
                            dist(lm[9].x,lm[9].y,lm[12].x,lm[12].y)>0.12&&
                            dist(lm[13].x,lm[13].y,lm[16].x,lm[16].y)>0.10&&
                            dist(lm[17].x,lm[17].y,lm[20].x,lm[20].y)>0.10&&!ip;
                    hds.push({h,lm,it,tt,ip,io,px:(it.x+tt.x)/2,py:(it.y+tt.y)/2});
                    drawConnectors(ctx,lm,HAND_CONNECTIONS,{color:h==='Right'?'#0C0':'#09F',lineWidth:2});
                    drawLandmarks(ctx,lm,{color:ip?'#F00':'#FF0',lineWidth:1});
                }
            }
            const lh=hds.find(h=>h.h==='Left');
            const rh=hds.find(h=>h.h==='Right');
            if(lh) {
                ldot.classList.add('active');
                ltxt.textContent=lh.ip?'Izq:ü§è':(lh.io?'Izq:‚úã':'Izq:üëä');
            } else {
                ldot.classList.remove('active');
                ltxt.textContent='Izq:--';
            }
            if(rh) {
                rdot.classList.add('active');
                rtxt.textContent=rh.ip?'Der:ü§è':(rh.io?'Der:‚úã':'Der:üëä');
            } else {
                rdot.classList.remove('active');
                rtxt.textContent='Der:--';
            }
            let act='Esperando...';
            if(rh&&rh.io&&lh&&lh.ip) {
                movF(lh.it,lh.tt,true);
                act='‚úãü§è MOVER PARTE';
                rot=false; mv=false; lsd=null;
            } else if(lh&&rh&&lh.ip&&rh.ip) {
                zoom({x:lh.px,y:lh.py},{x:rh.px,y:rh.py});
                act='ü§èü§è ZOOM';
                rot=false; mv=false;
                if(sel){sel.material.emissive.setHex(0x000000);sel=null;mvf=false;}
            } else if(rh&&rh.ip&&(!lh||!lh.ip)) {
                rotR(rh.it,rh.tt);
                act='ü§è ROTANDO';
                mv=false; lsd=null;
                if(sel){sel.material.emissive.setHex(0x000000);sel=null;mvf=false;}
            } else if(lh&&lh.ip&&(!rh||!rh.ip)) {
                movL(lh.it,lh.tt);
                act='ü§è MOVIENDO';
                rot=false; lsd=null;
                if(sel){sel.material.emissive.setHex(0x000000);sel=null;mvf=false;}
            } else {
                rot=false; mv=false; lsd=null;
                if(sel){sel.material.emissive.setHex(0x000000);sel=null;mvf=false;}
            }
            inst.innerHTML=act;
            if(obj) renderer.render(scene,cam);
            ctx.restore();
        }

        const hnds=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hnds.setOptions({maxNumHands:2,modelComplexity:0,minDetectionConfidence:0.6,minTrackingConfidence:0.6});
        hnds.onResults(onRes);

        async function start() {
            try {
                const strm=await navigator.mediaDevices.getUserMedia({video:{facingMode:'user',width:{ideal:640},height:{ideal:480}}});
                vid.srcObject=strm;
                await vid.play();
                const cf=new Camera(vid,{onFrame:async()=>{await hnds.send({image:vid});},width:640,height:480});
                cf.start();
                started=true;
                loading.textContent='Iniciando IA...';
                setTimeout(()=>{if(obj)loading.style.display='none';},1500);
            } catch(e) {
                console.error(e);
                loading.innerHTML='‚ùå Error de c√°mara<br><small>Permite acceso en configuraci√≥n</small>';
                startBtn.textContent='Reintentar';
                startBtn.style.display='block';
            }
        }

        startBtn.onclick=()=>{
            startBtn.style.display='none';
            loading.innerHTML='Accediendo a c√°mara...';
            start();
        };

        if(navigator.mediaDevices) {
            setTimeout(()=>{if(!started) startBtn.style.display='block';},500);
        } else {
            loading.innerHTML='‚ùå Navegador no compatible';
        }
    </script>
</body>
</html>
